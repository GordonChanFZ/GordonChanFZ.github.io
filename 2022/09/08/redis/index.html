<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>redis | 个人博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="./favicon.ico">
    <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?55943ae09e5901d7a9f5705133737eec";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
           </script>
    <script src="https://hm.baidu.com/hm.js?xxxxxxxxxxx"></script>
    <meta name="description" content="会思考的芦苇。">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta name="robots" content="all">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <link rel="preload" href="./assets/css/0.styles.f4f644f3.css" as="style"><link rel="preload" href="./assets/js/app.4a054e09.js" as="script"><link rel="preload" href="./assets/js/12.ef481976.js" as="script"><link rel="preload" href="./assets/js/1.8757f81f.js" as="script"><link rel="preload" href="./assets/js/8.d3843147.js" as="script"><link rel="preload" href="./assets/js/30.e6c3ce92.js" as="script"><link rel="prefetch" href="./assets/js/10.32428f77.js"><link rel="prefetch" href="./assets/js/11.9ff4207a.js"><link rel="prefetch" href="./assets/js/13.2722be32.js"><link rel="prefetch" href="./assets/js/14.4824fa41.js"><link rel="prefetch" href="./assets/js/15.0dc7f91d.js"><link rel="prefetch" href="./assets/js/16.299fdde2.js"><link rel="prefetch" href="./assets/js/17.1e44a945.js"><link rel="prefetch" href="./assets/js/18.3261a043.js"><link rel="prefetch" href="./assets/js/19.30c90430.js"><link rel="prefetch" href="./assets/js/20.166d90b0.js"><link rel="prefetch" href="./assets/js/21.0fcbf5a4.js"><link rel="prefetch" href="./assets/js/22.6af3a4fc.js"><link rel="prefetch" href="./assets/js/23.9396f6fd.js"><link rel="prefetch" href="./assets/js/24.d98df8ba.js"><link rel="prefetch" href="./assets/js/25.d472286f.js"><link rel="prefetch" href="./assets/js/26.b35845be.js"><link rel="prefetch" href="./assets/js/27.63c55d33.js"><link rel="prefetch" href="./assets/js/28.abc9dbd1.js"><link rel="prefetch" href="./assets/js/29.02bce782.js"><link rel="prefetch" href="./assets/js/3.fbe458d0.js"><link rel="prefetch" href="./assets/js/31.404c8479.js"><link rel="prefetch" href="./assets/js/32.8346822d.js"><link rel="prefetch" href="./assets/js/33.d1030fd2.js"><link rel="prefetch" href="./assets/js/34.4f8897ae.js"><link rel="prefetch" href="./assets/js/35.a64d3007.js"><link rel="prefetch" href="./assets/js/36.319828bf.js"><link rel="prefetch" href="./assets/js/37.f035f804.js"><link rel="prefetch" href="./assets/js/38.b4d34098.js"><link rel="prefetch" href="./assets/js/39.5e2946eb.js"><link rel="prefetch" href="./assets/js/4.320b9a30.js"><link rel="prefetch" href="./assets/js/40.9a7e2a95.js"><link rel="prefetch" href="./assets/js/41.940568cc.js"><link rel="prefetch" href="./assets/js/42.f0d933b0.js"><link rel="prefetch" href="./assets/js/43.04968e06.js"><link rel="prefetch" href="./assets/js/44.27ae804b.js"><link rel="prefetch" href="./assets/js/45.33e2561d.js"><link rel="prefetch" href="./assets/js/46.a05970d7.js"><link rel="prefetch" href="./assets/js/47.324e290d.js"><link rel="prefetch" href="./assets/js/48.2dbd07d8.js"><link rel="prefetch" href="./assets/js/49.125aba48.js"><link rel="prefetch" href="./assets/js/5.db49bb0d.js"><link rel="prefetch" href="./assets/js/6.4565405f.js"><link rel="prefetch" href="./assets/js/7.92a5ed22.js"><link rel="prefetch" href="./assets/js/9.d167197e.js">
    <link rel="stylesheet" href="./assets/css/0.styles.f4f644f3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Gordon</h3> <p class="description" data-v-59e6cb88>会思考的芦苇。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>Gordon</span>
          
        <span data-v-59e6cb88>2018 - </span>
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><img src="./logo.png" alt="个人博客" class="logo"> <span class="site-name">个人博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./" class="nav-link"><i class="iconfont reco-home"></i>
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      计算引擎
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./计算引擎/flink.html" class="nav-link"><i class="undefined"></i>
  flink
</a></li><li class="dropdown-item"><!----> <a href="/./计算引擎/spark.html" class="nav-link"><i class="undefined"></i>
  spark
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      存储引擎
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./存储引擎/ElasticSearch.html" class="nav-link"><i class="undefined"></i>
  ElasticSearch
</a></li><li class="dropdown-item"><!----> <a href="/./存储引擎/hbase.html" class="nav-link"><i class="undefined"></i>
  hbase
</a></li><li class="dropdown-item"><!----> <a href="/./存储引擎/redis.html" class="nav-link"><i class="undefined"></i>
  redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      云原生
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./云原生/Docker.html" class="nav-link"><i class="undefined"></i>
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      中间件
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./中间件/kafka.html" class="nav-link"><i class="undefined"></i>
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/./中间件/Sqoop基本使用.html" class="nav-link"><i class="undefined"></i>
  Sqoop基本使用
</a></li></ul></div></div><div class="nav-item"><a href="/./tool/emoji/我的常用emoji.html" class="nav-link"><i class="undefined"></i>
  工具
</a></div><div class="nav-item"><a href="/./aboutme.html" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div> <a href="https://github.com/GordonChanFZ/gordonchanfz.github.io/" target="_blank" rel="noopener noreferrer" class="repo-link"><i class="iconfont reco-github"></i>
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="./avatar.jpeg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    Gordon
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>28</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>34</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41><li class="social-item" data-v-1fad0c41><i class="iconfont reco-github" style="color:#e15b64;" data-v-1fad0c41></i></li></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/./" class="nav-link"><i class="iconfont reco-home"></i>
  博客
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      计算引擎
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./计算引擎/flink.html" class="nav-link"><i class="undefined"></i>
  flink
</a></li><li class="dropdown-item"><!----> <a href="/./计算引擎/spark.html" class="nav-link"><i class="undefined"></i>
  spark
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      存储引擎
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./存储引擎/ElasticSearch.html" class="nav-link"><i class="undefined"></i>
  ElasticSearch
</a></li><li class="dropdown-item"><!----> <a href="/./存储引擎/hbase.html" class="nav-link"><i class="undefined"></i>
  hbase
</a></li><li class="dropdown-item"><!----> <a href="/./存储引擎/redis.html" class="nav-link"><i class="undefined"></i>
  redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      云原生
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./云原生/Docker.html" class="nav-link"><i class="undefined"></i>
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      中间件
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./中间件/kafka.html" class="nav-link"><i class="undefined"></i>
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/./中间件/Sqoop基本使用.html" class="nav-link"><i class="undefined"></i>
  Sqoop基本使用
</a></li></ul></div></div><div class="nav-item"><a href="/./tool/emoji/我的常用emoji.html" class="nav-link"><i class="undefined"></i>
  工具
</a></div><div class="nav-item"><a href="/./aboutme.html" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div> <a href="https://github.com/GordonChanFZ/gordonchanfz.github.io/" target="_blank" rel="noopener noreferrer" class="repo-link"><i class="iconfont reco-github"></i>
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>redis</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>Gordon</span>
          
        <span data-v-59e6cb88>2018 - </span>
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">redis</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>Gordon</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2022-9-8</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>kv存储</span><span class="tag-item" data-v-8a445198>实时</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>Redis是基于c语言编写的开源非关系型内存数据库，可以用作数据库、缓存、消息中间件。</p> <p>脑图</p> <p><img src="./assets/img/image-20230327130118195.84e23681.png" alt="image-20230327130118195"></p> <h2 id="redis基本数据结构"><a href="#redis基本数据结构" class="header-anchor">#</a> redis基本数据结构</h2> <h3 id="redis核心对象"><a href="#redis核心对象" class="header-anchor">#</a> <strong>Redis</strong>核心对象</h3> <p>在Redis中有一个<strong>核心的对象</strong>叫做<code>redisObject</code> ，是用来表示所有的key和value的，用redisObject结构体来表示<code>String、Hash、List、Set、ZSet</code>五种数据类型。</p> <p><code>redisObject</code>的源代码在<code>redis.h</code>中，使用c语言写的，感兴趣的可以自行查看，关于redisObject我这里画了一张图，表示redisObject的结构如下所示：</p> <p><img src="./assets/img/image-20230327130439266.bfb41b81.png" alt="image-20230327130439266"><br>
在redisObject中type表示属于哪种数据类型，encoding表示该数据的存储方式，也就是底层的实现的该数据类型的数据结构。因此这篇文章具体介绍的也是encoding对应的部分。<br>
那么encoding中的存储类型又分别表示什么意思呢？具体数据类型所表示的含义，如下图所示：</p> <p><img src="./assets/img/image-20230327130517934.13387ed9.png" alt="image-20230327130517934"></p> <p>图片截图出自《Redis设计与实现第二版》</p> <p>可能看完这图，还是觉得一脸懵。不慌，会进行五种数据结构的详细介绍，这张图只是让你找到每种中数据结构对应的储存类型有哪些，大概脑子里有个印象。</p> <p>举一个简单的例子，你在Redis中设置一个字符串<code>key 234</code>，然后查看这个字符串的存储类型就会看到为int类型，非整数型的使用的是embstr储存类型，具体操作如下图所示：</p> <p><img src="./assets/img/image-20230327130540864.71553d11.png" alt="image-20230327130540864"></p> <h3 id="string类型"><a href="#string类型" class="header-anchor">#</a> String类型</h3> <p>String是Redis最基本的数据类型，上面的简介中也说到Redis是用c语言开发的。但是Redis中的字符串和c语言中的字符串类型却是有明显的区别。</p> <p>String类型的数据结构存储方式有三种<code>int、raw、embstr</code>。那么这三种存储方式有什么区别呢？</p> <p><strong>int</strong></p> <p>Redis中规定假如存储的是<strong>整数型值</strong>，比如<code>set num 123</code>这样的类型，就会使用 int的存储方式进行存储，在redisObject的<strong>ptr属性</strong>中就会保存该值。</p> <p><img src="./assets/img/image-20230327130706332.2d2d430d.png" alt="image-20230327130706332"></p> <p><strong>SDS（embstr-&gt;raw）</strong></p> <p>假如存储的<strong>字符串是一个字符串值并且长度大于44个字节</strong>就会使用<code>SDS（simple dynamic string）</code>方式进行存储，并且encoding设置为raw；若是<strong>字符串长度小于等于44个字节</strong>就会将encoding改为embstr来保存字符串。</p> <p>(3.2之前是39字节)</p> <p>SDS称为<strong>简单动态字符串</strong>，对于SDS中的定义在Redis的源码中有的三个属性<code>int len、int free、char buf[]</code>。</p> <p>len保存了字符串的长度，free表示buf数组中未使用的字节数量，buf数组则是保存字符串的每一个字符元素。</p> <p>因此当你在Redsi中存储一个字符串Hello时，根据Redis的源代码的描述可以画出SDS的形式的redisObject结构图如下图所示：</p> <p><img src="./assets/img/image-20230327143018369.2616e227.png" alt="image-20230327143018369"></p> <p>SDS还提供<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略。在为字符串分配空间时，分配的空间比实际要多，这样就能<strong>减少连续的执行字符串增长带来内存重新分配的次数</strong>。</p> <p>当字符串被缩短的时候，SDS也不会立即回收不适用的空间，而是通过<code>free</code>属性将不使用的空间记录下来，等后面使用的时候再释放。</p> <p>具体的空间预分配原则是：<strong>当修改字符串后的长度len小于1MB，就会预分配和len一样长度的空间，即len=free；若是len大于1MB，free分配的空间大小就为1MB</strong>。</p> <p>SDS是二进制安全的，除了可以储存字符串以外还可以储存二进制文件（如图片、音频，视频等文件的二进制数据）；而c语言中的字符串是以空字符串作为结束符，一些图片中含有结束符，因此不是二进制安全的。</p> <p><strong>String类型应用</strong></p> <p>说到这里我相信很多人可以说已经精通Redis的String类型了，但是纯理论的精通，理论还是得应用实践，上面说到String可以用来存储图片，现在就以图片存储作为案例实现。</p> <p>（1）首先要把上传得图片进行编码，这里写了一个工具类把<strong>图片处理成了Base64</strong>得编码形式，具体得实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**

   * 将图片内容处理成Base64编码格式

   * @param file

   * @return

   */</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">encodeImg</span><span class="token punctuation">(</span><span class="token class-name">MultipartFile</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> imgBytes <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

   <span class="token keyword">try</span> <span class="token punctuation">{</span>

      imgBytes <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token punctuation">}</span>

    <span class="token class-name">BASE64Encoder</span> encoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BASE64Encoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> imgBytes<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">?</span><span class="token keyword">null</span><span class="token operator">:</span>encoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>imgBytes <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>（2）第二步就是把处理后的图片字符串格式存储进Redis中，实现得代码如下所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**

   * Redis存储图片

   * @param file

   * @return

   */</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">uploadImageServiceImpl</span><span class="token punctuation">(</span><span class="token class-name">MultipartFile</span> image<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token class-name">String</span> imgId <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token class-name">String</span> imgStr<span class="token operator">=</span> <span class="token class-name">ImageUtils</span><span class="token punctuation">.</span><span class="token function">encodeImg</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>

    redisUtils<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>imgId <span class="token punctuation">,</span> imgStr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 后续操作可以把imgId存进数据库对应的字段，如果需要从redis中取出，只要获取到这个字段后从redis中取出即可。</span>

  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这样就是实现了图片得二进制存储，当然String类型得数据结构得应用也还有常规计数：<strong>统计微博数、统计粉丝数</strong>等。</p> <h3 id="hash类型"><a href="#hash类型" class="header-anchor">#</a> <strong>Hash</strong>类型</h3> <p>Hash对象的实现方式有两种分别是<code>ziplist、hashtable</code>，其中hashtable的存储方式key是String类型的，value也是以<code>key value</code>的形式进行存储。</p> <p>在redis.conf的默认配置为：</p> <p><img src="./assets/img/image-20230327152128771.40426da2.png" alt="image-20230327152128771"></p> <p><strong>当hash对象同时满足以下两个条件的时候，使用ziplist编码否则使用hashtable：</strong></p> <p><strong>a、所有的键值对的键和值的字符串长度都不超过64byte（一个英文字母一个字节）；</strong></p> <p><strong>b、哈希对象保存的键值对数量不超过512个。</strong></p> <p>字典类型的底层就是hashtable实现的，明白了字典的底层实现原理也就是明白了hashtable的实现原理，hashtable的实现原理可以于HashMap的是底层原理相类比。</p> <p><strong>字典</strong></p> <p>两者在新增时都会<strong>通过key计算出数组下标，不同的是计算法方式不同</strong>，<strong>HashMap中是以hash函数</strong>的方式，而<strong>hashtable中计算出hash值后，还要通过sizemask 属性和哈希值再次得到数组下标</strong>。</p> <p>我们知道hash表最大的问题就是hash冲突，为了解决hash冲突，假如hashtable中不同的key通过计算得到同一个index，就会形成单向链表（<strong>链地址法</strong>），如下图所示：</p> <p><img src="./assets/img/image-20230327144808925.5b730ead.png" alt="image-20230327144808925"></p> <p><strong>rehash</strong></p> <p>在字典的底层实现中，value对象以每一个dictEntry的对象进行存储，当hash表中的存放的键值对不断的增加或者减少时，需要对hash表进行一个扩展或者收缩。</p> <p>这里就会和HashMap一样也会就进行rehash操作，进行重新散列排布。从上图中可以看到有<code>ht[0]</code>和<code>ht[1]</code>两个对象，先来看看对象中的属性是干嘛用的。</p> <p>在hash表结构定义中有四个属性分别是<code>dictEntry **table、unsigned long size、unsigned long sizemask、unsigned long used</code>，分别表示的含义就是<strong>哈希表数组、hash表大小、用于计算索引值，总是等于size-1、hash表中已有的节点数</strong>。</p> <p>ht[0]是用来最开始存储数据的，当要进行扩展或者收缩时，ht[0]的大小就决定了ht[1]的大小，ht[0]中的所有的键值对就会重新散列到ht[1]中。</p> <p>扩展操作：ht[1]扩展的大小是比当前 ht[0].used 值的二倍大的第一个 2 的整数幂；收缩操作：ht[0].used 的第一个大于等于的 2 的整数幂。</p> <p>当ht[0]上的所有的键值对都rehash到ht[1]中，会重新计算所有的数组下标值，当数据迁移完后ht[0]就会被释放，然后将ht[1]改为ht[0]，并新创建ht[1]，为下一次的扩展和收缩做准备。</p> <p><strong>渐进式rehash</strong></p> <p>假如在rehash的过程中数据量非常大，Redis不是一次性把全部数据rehash成功，这样会导致Redis对外服务停止，Redis内部为了处理这种情况采用<strong>渐进式的rehash</strong>。</p> <p>Redis将所有的rehash的操作分成多步进行，直到都rehash完成，具体的实现与对象中的<code>rehashindex</code>属性相关，<strong>若是rehashindex 表示为-1表示没有rehash操作</strong>。</p> <p>当rehash操作开始时会将该值改成0，在渐进式rehash的过程<strong>更新、删除、查询会在ht[0]和ht[1]中都进行</strong>，比如更新一个值先更新ht[0]，然后再更新ht[1]。</p> <p>而新增操作直接就新增到ht[1]表中，ht[0]不会新增任何的数据，这样保证<strong>ht[0]只减不增，直到最后的某一个时刻变成空表</strong>，这样rehash操作完成。</p> <p><strong>ziplist</strong></p> <p>压缩列表<code>（ziplist）</code>是一组连续内存块组成的顺序的数据结构，压缩列表能够节省空间，压缩列表中使用多个节点来存储数据。</p> <p>压缩列表是列表键和哈希键底层实现的原理之一，<strong>压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间</strong>，压缩列表的内存结构图如下：</p> <p><img src="./assets/img/image-20230327150044943.7ec8838c.png" alt="image-20230327150044943"></p> <p>压缩列表中每一个节点表示的含义如下所示：</p> <ol><li><p><code>zlbytes</code>：4个字节的大小，记录压缩列表占用内存的字节数。</p></li> <li><p><code>zltail</code>：4个字节大小，记录表尾节点距离起始地址的偏移量，用于快速定位到尾节点的地址。</p></li> <li><p><code>zllen</code>：2个字节的大小，记录压缩列表中的节点数。</p></li> <li><p><code>entry</code>：表示列表中的每一个节点。</p></li> <li><p><code>zlend</code>：表示压缩列表的特殊结束符号<code>'0xFF'</code>。</p></li></ol> <p>在压缩列表中每一个entry节点又有三部分组成，包括<code>previous_entry_length、encoding、content</code>。</p> <ol><li><p><code>previous_entry_length</code>表示前一个节点entry的长度，可用于计算前一个节点的真实地址，因为他们的地址是连续的。</p></li> <li><p>encoding：这里保存的是content的内容类型和长度。</p></li> <li><p>content：content保存的是每一个节点的内容。</p></li></ol> <p><strong>hash的应用场景</strong></p> <p><strong>存储用户数据</strong>（ht）</p> <p>第一个场景比如我们要<strong>储存用户信息</strong>，一般使用用户的ID作为key值，保持唯一性，用户的其他信息（地址、年龄、生日、电话号码等）作为value值存储。</p> <p>若是传统的实现就是将用户的信息封装成为一个对象，通过序列化存储数据，当需要获取用户信息的时候，就会通过反序列化得到用户信息。</p> <p><img src="./assets/img/image-20230327151252195.934ceef8.png" alt="image-20230327151252195"></p> <p>但是这样必然会造成<strong>序列化和反序列化的性能的开销</strong>，并且若是只修改其中的一个属性值，就需要把整个对象序列化出来，操作的动作太大，造成不必要的性能开销。</p> <p>若是使用Redis的hash来存储用户数据，就会将原来的value值又看成了一个k v形式的存储容器，这样就不会带来序列化的性能开销的问题。</p> <p><img src="./assets/img/image-20230327151343547.848ac649.png" alt="image-20230327151343547"></p> <p><strong>分布式生成唯一ID</strong></p> <p>第二个场景就是生成分布式的唯一ID，这个场景下就是把redis封装成了一个工具类进行实现，实现的代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token comment">// offset表示的是id的递增梯度值</span>

  <span class="token keyword">public</span> <span class="token class-name">Long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token class-name">String</span> hashKey<span class="token punctuation">,</span><span class="token class-name">Long</span> offset<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BusinessException</span><span class="token punctuation">{</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> offset<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        offset<span class="token operator">=</span><span class="token number">1L</span><span class="token punctuation">;</span>

      <span class="token punctuation">}</span>

      <span class="token comment">// 生成唯一id</span>

      <span class="token keyword">return</span> redisUtil<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hashKey<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token comment">//若是出现异常就是用uuid来生成唯一的id值</span>

      <span class="token keyword">int</span> randNo<span class="token operator">=</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>randNo <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        randNo<span class="token operator">=</span><span class="token operator">-</span>randNo<span class="token punctuation">;</span>

      <span class="token punctuation">}</span>

     <span class="token keyword">return</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;%16d&quot;</span><span class="token punctuation">,</span> randNo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>UUID</p> <p>算法的核心思想是结合机器的网卡、当地时间、一个随记数来生成UUID。</p> <ul><li>优点：本地生成，生成简单，性能好，没有高可用风险</li> <li>缺点：长度过长，存储冗余，且无序不可读，查询效率低</li></ul> <p>Redis生成方案</p> <p>利用redis的incr原子性操作自增，一般算法为： <strong>年份 + 当天距当年第多少天 + 天数 + 小时 + redis自增</strong></p> <p>优点：</p> <ul><li>有序递增，可读性强</li></ul> <p>缺点：</p> <ul><li>占用带宽，每次要向redis进行请求</li> <li>存在单点问题，如果集群部署，复杂而如果单单只为了生成ID，得不偿失</li></ul> <p>算法可以调整为 就一个 redis自增，不需要什么年份，多少天等。</p> <h3 id="list类型"><a href="#list类型" class="header-anchor">#</a> <strong>List</strong>类型</h3> <p>Redis中的列表在3.2之前的版本是使用<code>ziplist</code>和<code>linkedlist</code>进行实现的。在3.2之后的版本就是引入了<code>quicklist</code>替代了ziplist+linkedlist，不需要再进行编码转换。</p> <p>在redis.conf的默认配置为：</p> <p><img src="./assets/img/image-20230327155216511.fbfdc3e6.png" alt="image-20230327155216511"></p> <p>列表类型 (List) 是⼀个使用线性结构存储的结构，它的元素插入会按照先后顺序存储到链表结构中。<br>
列表类型的底层数据结构可以是压缩列表（ZipList)或者链表（LinkedList）</p> <p><strong>同时满足下述两个条件使用ziplist，否则使用链表</strong></p> <p><strong>1.当列表对象的所有字符串元素长度都不超过64字节</strong></p> <p><strong>2.保存的元素数量不超过512个</strong></p> <p>ziplist压缩列表上面已经讲过了，我们来看看linkedlist和quicklist的结构是怎么样的。</p> <p>linkedlist是一个双向链表，他和普通的链表一样都是由指向前后节点的指针。插入、修改、更新的时间复杂度尾O(1)，但是查询的时间复杂度确实O(n)。</p> <p>linkedlist和quicklist的底层实现是采用链表进行实现，在c语言中并没有内置的链表这种数据结构，Redis实现了自己的链表结构。</p> <p><img src="./assets/img/image-20230327154220677.dbef7b38.png" alt="image-20230327154220677"></p> <p>Redis中链表的特性：</p> <ol><li><p>每一个节点都有指向前一个节点和后一个节点的指针。</p></li> <li><p>头节点和尾节点的prev和next指针指向为null，所以链表是无环的。</p></li> <li><p>链表有自己长度的信息，获取长度的时间复杂度为O(1)。</p></li></ol> <h3 id="set集合"><a href="#set集合" class="header-anchor">#</a> Set集合</h3> <p>Redis中列表和集合都可以用来存储字符串，但是<strong>Set是不可重复的集合，而List列表可以存储相同的字符串</strong>，Set集合是无序的这个和后面讲的ZSet有序集合相对。</p> <p>Set的底层实现是<strong>ht和intset</strong>。</p> <p><strong>同时满足以下两个条件使用intset，否则使用ht：</strong></p> <p><strong>1.所有的元素均为整数；</strong></p> <p><strong>2.元素个数不超过512</strong>。</p> <p>ht（哈希表）前面已经详细了解过，下面我们来看看inset类型的存储结构。</p> <p>inset也叫做整数集合，用于保存整数值的数据结构类型，它可以保存<code>int16_t</code>、<code>int32_t</code> 或者<code>int64_t</code> 的整数值。</p> <p>在整数集合中，有三个属性值<code>encoding、length、contents[]</code>，分别表示编码方式、整数集合的长度、以及元素内容，length就是记录contents里面的大小。</p> <p>在整数集合新增元素的时候，若是超出了原集合的长度大小，就会对集合进行升级，具体的升级过程如下：</p> <ol><li><p>首先扩展底层数组的大小，并且数组的类型为新元素的类型。</p></li> <li><p>然后将原来的数组中的元素转为新元素的类型，并放到扩展后数组对应的位置。</p></li> <li><p>整数集合升级后就不会再降级，编码会一直保持升级后的状态。</p></li></ol> <p><strong>应用场景</strong></p> <p>Set集合的应用场景可以用来<strong>去重、抽奖、共同好友、二度好友</strong>等业务类型。</p> <h3 id="zset集合"><a href="#zset集合" class="header-anchor">#</a> <strong>ZSet</strong>集合</h3> <p>ZSet是有序集合，从上面的图中可以看到ZSet的底层实现是<code>ziplist</code>和<code>skiplist</code>实现的，ziplist上面已经详细讲过，这里来讲解skiplist的结构实现。</p> <p>在redis.conf的默认配置为：</p> <p><img src="./assets/img/image-20230327161417187.b7b7374f.png" alt="image-20230327161417187"></p> <p><strong>同时满足以下两个条件使用ziplist，否则使用skiplist：</strong></p> <p><strong>1.有序集合保存的元素数量不超过128个</strong></p> <p><strong>2.有序集合保存的所有元素的长度不超过64字节</strong></p> <p><code>skiplist</code>也叫做<strong>跳跃表</strong>，跳跃表是一种有序的数据结构，它通过每一个节点维持多个指向其它节点的指针，从而达到快速访问的目的。</p> <p>skiplist由如下几个特点：</p> <ol><li><p>有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大。</p></li> <li><p>每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点。</p></li> <li><p>每一层的每一个每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针。</p></li> <li><p>如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点。</p></li></ol> <p>具体实现的结构图如下所示：</p> <p><img src="./assets/img/image-20230327161834405.907919ae.png" alt="image-20230327161834405"></p> <p>在跳跃表的结构中有head和tail表示指向头节点和尾节点的指针，能后快速的实现定位。level表示层数，len表示跳跃表的长度，BW表示后退指针，在从尾向前遍历的时候使用。</p> <p>BW下面还有两个值分别表示分值（score）和成员对象（各个节点保存的成员对象）。</p> <p>跳跃表的实现中，除了最底层的一层保存的是原始链表的完整数据，上层的节点数会越来越少，并且跨度会越来越大。</p> <p>跳跃表的上面层就相当于索引层，都是为了找到最后的数据而服务的，数据量越大，跳表所体现的查询的效率就越高，和平衡树的查询效率相差无几。</p> <p><strong>应用场景</strong></p> <p>因为ZSet是有序的集合，因此ZSet在实现排序类型的业务是比较常见的，比如在首页推荐10个最热门的帖子，也就是阅读量由高到低，排行榜的实现等业务。</p> <h2 id="redis内存分配策略"><a href="#redis内存分配策略" class="header-anchor">#</a> <strong>Redis</strong>内存分配策略</h2> <p><strong>假如你的Redis内存满了怎么办？<strong>在Redis中有配置参数<code>maxmemory</code>可以</strong>设置Redis内存的大小</strong>。</p> <p>倘若实际的存储中超出了Redis的配置参数的大小时，Redis中有<strong>淘汰策略</strong>，把<strong>需要淘汰的key给淘汰掉，整理出干净的一块内存给新的key值使用</strong>。</p> <p>接下来我们就详细的聊一聊Redis中的淘汰策略，并且深入的理解每个淘汰策略的原理和应用的场景。</p> <h3 id="淘汰策略"><a href="#淘汰策略" class="header-anchor">#</a> <strong>淘汰策略</strong></h3> <p>Redis提供了<strong>6种的淘汰策略</strong>，其中默认的是<code>noeviction</code>，这6中淘汰策略如下：</p> <ol><li><p><code>noeviction</code>(<strong>默认策略</strong>)：若是内存的大小达到阀值的时候，所有申请内存的指令都会报错。</p></li> <li><p><code>allkeys-lru</code>：所有key都是使用<strong>LRU算法</strong>进行淘汰。</p></li> <li><p><code>volatile-lru</code>：所有<strong>设置了过期时间的key使用LRU算法</strong>进行淘汰。</p></li> <li><p><code>allkeys-random</code>：所有的key使用<strong>随机淘汰</strong>的方式进行淘汰。</p></li> <li><p><code>volatile-random</code>：所有<strong>设置了过期时间的key使用随机淘汰</strong>的方式进行淘汰。</p></li> <li><p><code>volatile-ttl</code>：所有设置了过期时间的key<strong>根据过期时间进行淘汰，越早过期就越快被淘汰</strong>。</p></li></ol> <p>假如在Redis中的数据有<strong>一部分是热点数据，而剩下的数据是冷门数据</strong>，或者<strong>我们不太清楚我们应用的缓存访问分布状况</strong>，这时可以使用<code>allkeys-lru</code>。</p> <p>假如所有的数据访问的频率大概一样，就可以使用<code>allkeys-random</code>的淘汰策略。</p> <p>假如要配置具体的淘汰策略，可以在<code>redis.conf</code>配置文件中配置，具体配置如下所示：</p> <p><img src="./assets/img/image-20230327164705660.d3ab5082.png" alt="image-20230327164705660"></p> <p>这只需要把注释给打开就可以，并且配置指定的策略方式，另一种的配置方式就是命令的方式进行配置，具体的执行命令如下所示：</p> <p>// 获取maxmemory-policy配置</p> <p>127.0.0.1:6379&gt; config get maxmemory-policy</p> <p>// 设置maxmemory-policy配置为allkeys-lru</p> <p>127.0.0.1:6379&gt; config set maxmemory-policy allkeys-lru</p> <p>在介绍6种的淘汰策略方式的时候，说到了LRU算法，<strong>那么什么是LRU算法呢？</strong></p> <p><strong>LRU算法</strong></p> <p><code>LRU(Least Recently Used)</code>即表示最近最少使用，也就是在最近的时间内最少被访问的key，算法根据数据的历史访问记录来进行淘汰数据。</p> <p>它的核心的思想就是：<strong>假如一个key值在最近很少被使用到，那么在将来也很少会被访问</strong>。</p> <p>实际上Redis实现的LRU并不是真正的LRU算法，也就是名义上我们使用LRU算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的。</p> <p>Redis使用的是近似的LRU算法，<strong>通过随机采集法淘汰key，每次都会随机选出5个key，然后淘汰里面最近最少使用的key</strong>。</p> <p>这里的5个key只是默认的个数，具体的个数也可以在配置文件中进行配置，在配置文件中的配置如下图所示：</p> <p><img src="./assets/img/image-20230327164855378.d494ec25.png" alt="image-20230327164855378"></p> <p>当近似LRU算法取值越大的时候就会越接近真实的LRU算法，可以这样理解，因为<strong>取值越大那么获取的数据就越全，淘汰中的数据的就越接近最近最少使用的数据</strong>。</p> <p>那么为了实现根据时间实现LRU算法，Redis必须为每个key中额外的增加一个内存空间用于存储每个key的时间，大小是3字节。</p> <p>在Redis 3.0中对近似的LRU算法做了一些优化，Redis中会维护大小是<code>16</code>的一个候选池的内存。</p> <p>当第一次随机选取的采样数据，数据都会被放进候选池中，并且候选池中的数据会根据时间进行排序。</p> <p>当第二次以后选取的数据，只有<strong>小于候选池内的最小时间</strong>的才会被放进候选池中。</p> <p>当某一时刻候选池的数据满了，那么时间最大的key就会被挤出候选池。当执行淘汰时，直接从候选池中选取最近访问时间最小的key进行淘汰。</p> <p>这样做的目的就是选取出最近似符合最近最少被访问的key值，能够正确的淘汰key值，因为随机选取的样本中的最小时间可能不是真正意义上的最小时间。</p> <p>但是LRU算法有一个弊端：就是假如一个key值在以前都没有被访问到，然而最近一次被访问到了，那么就会认为它是热点数据，不会被淘汰。</p> <p>然而有些数据以前经常被访问到，只是最近的时间内没有被访问到，这样就导致这些数据很可能被淘汰掉，这样一来就会出现误判而淘汰热点数据。</p> <p>于是在Redis 4.0的时候除了LRU算法，新加了一种LFU算法，<strong>那么什么是LFU算法算法呢？</strong></p> <p><strong>LFU算法</strong></p> <p><code>LFU(Least Frequently Used)</code>即表示最近频繁被使用，也就是最近的时间段内，频繁被访问的key，它以最近的时间段的被访问次数的频率作为一种判断标准。</p> <p>它的核心思想就是：根据key最近被访问的频率进行淘汰，比较少被访问的key优先淘汰，反之则优先保留。</p> <p>LFU算法反映了一个key的热度情况，不会因为LRU算法的偶尔一次被访问被认为是热点数据。</p> <p>在LFU算法中支持<code>volatile-lfu</code>策略和<code>allkeys-lfu</code>策略。</p> <p>以上介绍了Redis的6种淘汰策略，这6种淘汰策略旨在告诉我们怎么做，但是什么时候做？这个还没说，下面我们就来详细的了解Redis什么时候执行淘汰策略。</p> <h3 id="删除过期键策略"><a href="#删除过期键策略" class="header-anchor">#</a> <strong>删除过期键策略</strong></h3> <p>在Redis种有三种删除的操作此策略，分别是：</p> <ol><li><p><strong>定时删除</strong>：创建一个定时器，定时的执行对key的删除操作。</p></li> <li><p><strong>惰性删除</strong>：每次只有再访问key的时候，才会检查key的过期时间，若是已经过期了就执行删除。</p></li> <li><p><strong>定期删除</strong>：每隔一段时间，就会检查删除掉过期的key。</p></li></ol> <p><strong>定时删除</strong>对于<strong>内存来说是友好的</strong>，定时清理出干净的空间，但是对于<strong>cpu来说并不是友好的</strong>，程序需要维护一个定时器，这就会占用cpu资源。</p> <p><strong>惰性的删除</strong>对于<strong>cpu来说是友好的</strong>，cpu不需要维护其它额外的操作，但是对于<strong>内存来说是不友好的</strong>，因为要是有些key一直没有被访问到，就会一直占用着内存。</p> <p>定期删除是上面两种方案的折中方案**，每隔一段时间删除过期的key，也就是根据具体的业务，合理的取一个时间定期的删除key**。</p> <p>通过<strong>最合理控制删除的时间间隔</strong>来删除key，减<strong>少对cpu的资源的占用消耗</strong>，使删除操作合理化。</p> <p><strong>RDB和AOF 的淘汰处理</strong></p> <p>在Redis中持久化的方式有两种<code>RDB</code>和<code>AOF</code>。</p> <p>在RDB中是以快照的形式获取内存中某一时间点的数据副本，在创建RDB文件的时候可以通过<code>save</code>和<code>bgsave</code>命令执行创建RDB文件。</p> <p><strong>这两个命令都不会把过期的key保存到RDB文件中</strong>，这样也能达到删除过期key的效果。</p> <p>当在启动Redis载入RDB文件的时候，<code>Master</code>不会把过期的key载入，而<code>Slave</code>会把过期的key载入。</p> <p>在AOF模式下，Redis提供了Rewrite的优化措施，执行的命令分别是<code>REWRITEAOF</code>和<code>BGREWRITEAOF</code>，<strong>这两个命令都不会把过期的key写入到AOF文件中，也能删除过期key</strong>。</p> <h2 id="redis缓存三大问题"><a href="#redis缓存三大问题" class="header-anchor">#</a> <strong>Redis</strong>缓存三大问题</h2> <p>日常的开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题。</p> <p>一旦涉及大数据量的需求，如一些<strong>商品抢购</strong>的情景，或者<strong>主页访问量</strong>瞬间较大的时候，单一使用数据库来保存数据的系统会因为<strong>面向磁盘</strong>，<strong>磁盘读/写</strong>速度问题有严重的性能弊端，详细的<strong>磁盘读写原理</strong>请参考这一片[]。</p> <p>在这一瞬间成千上万的请求到来，需要系统在<strong>极短的时间</strong>内完成成<strong>千上万</strong>次的<strong>读/写操作</strong>，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p> <p>为了克服上述的问题，项目通常会引入<strong>NoSQL</strong>技术，这是一种<strong>基于内存</strong>的<strong>数据库</strong>，并且提供一定的<strong>持久化</strong>功能。</p> <p><code>Redis</code>技术就是<code>NoSQL</code>技术中的一种。<code>Redis</code>缓存的使用，极大的提升了应用程序的性能和效率，特别是<strong>数据查询</strong>方面。</p> <p>但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对<strong>数据的一致性</strong>要求很高，那么就不能使用<strong>缓存</strong>。</p> <p>另外的一些典型问题就是，<strong>缓存穿透</strong>、<strong>缓存击穿</strong>和<strong>缓存雪崩</strong>。</p> <h3 id="缓存穿透"><a href="#缓存穿透" class="header-anchor">#</a> <strong>缓存穿透</strong></h3> <p>缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力就会增大，缓存穿透的解决方案，有以下两种，<strong>推荐使用布隆过滤器</strong>：</p> <ol><li><p><strong>缓存空对象</strong>：代码维护较简单，但是效果不好。</p></li> <li><p><strong>布隆过滤器</strong>：代码维护复杂，效果很好。</p></li></ol> <p><strong>缓存空对象</strong></p> <p>缓存空对象是指当一个请求过来缓存中和数据库中都不存在该请求的数据，第一次请求就会跳过缓存进行数据库的访问，并且访问数据库后返回为空，此时也将该空对象进行缓存。</p> <p>若是再次进行访问该空对象的时候，就会直接<strong>击中缓存</strong>，而不是再次<strong>数据库</strong>：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//缓存空对象的实现代码如下：</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@Autowired</span>
     <span class="token class-name">UserDAO</span> userDAO<span class="token punctuation">;</span>
     <span class="token annotation punctuation">@Autowired</span>
     <span class="token class-name">RedisCache</span> redisCache<span class="token punctuation">;</span>
 
     <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">findUser</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token class-name">Object</span> object <span class="token operator">=</span> redisCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 缓存中存在，直接返回</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>object <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment">// 检验该对象是否为缓存空对象，是则直接返回null</span>
               <span class="token keyword">if</span><span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">NullValueResultDO</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span>object<span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  
               <span class="token comment">// 缓存中不存在，查询数据库</span>
               <span class="token class-name">User</span> user <span class="token operator">=</span> userDAO<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token comment">// 存入缓存</span>
               <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    redisCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 将空对象存进缓存</span>
                    <span class="token comment">//redisCache.put(Integer.toString(id), new NullValueResultDO());</span>
                   <span class="token comment">//缓存空对象的实现代码很简单，但是缓存空对象会带来比较大的问题，就是缓存中会存在很多空对象，占用内存的空间，浪费资源，一个解决的办法就是设置空对象的较短的过期时间：</span>
<span class="token comment">// 再缓存的时候，添加多一个该空对象的过期时间60秒</span>
redisCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">NullValueResultDO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               <span class="token keyword">return</span> user<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>          
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p><strong>布隆过滤器</strong></p> <p>布隆过滤器是一种基于<strong>概率</strong>的<strong>数据结构</strong>，主要用来判断某个元素是否在集合内，它具有<strong>运行速度快</strong>（时间效率），<strong>占用内存小</strong>的优点（空间效率），但是有一定的<strong>误识别率</strong>和<strong>删除困难</strong>的问题。它只能告诉你某个元素一定不在集合内或可能在集合内。</p> <p>在计算机科学中有一种思想：<strong>空间换时间，时间换空间</strong>。一般两者是不可兼得，而布隆过滤器运行效率和空间大小都兼得，它是怎么做到的呢？</p> <p>在布隆过滤器中引用了一个<strong>误判率</strong>的概念，即它可能会把不属于这个集合的元素认为可能属于这个集合，但是不会把属于这个集合的认为不属于这个集合，布隆过滤器的特点如下：</p> <ol><li><p>一个非常大<strong>的二进制位数组</strong> （数组里只有0和1）</p></li> <li><p>若干个<strong>哈希函数</strong></p></li> <li><p><strong>空间效率</strong>和<strong>查询效率高</strong></p></li> <li><p>不存在<strong>漏报</strong>（False Negative）：某个元素在某个集合中，肯定能报出来。</p></li> <li><p>可能存在<strong>误报</strong>（False Positive）：某个元素不在某个集合中，可能也被爆出来。</p></li> <li><p>不提供删除方法，代码维护困难。</p></li> <li><p>位数组初始化都为0，它不存元素的具体值，当元素经过哈希函数哈希后的值（也就是数组下标）对应的数组位置值改为1。</p></li></ol> <p>实际布隆过滤器存储数据和查询数据的原理图如下：</p> <p><img src="./assets/img/image-20230327170908194.ad09455b.png" alt="image-20230327170908194"></p> <p>可能很多读者看完上面的特点和原理图，还是看不懂，别急下面通过图解一步一步的讲解布隆过滤器，总而言之一句简单的话概括就是布隆过滤器是一个<strong>很大二进制</strong>的<strong>位数组</strong>，数组里面<strong>只存0和1</strong>。</p> <p>初始化的布隆过滤器的结构图如下：</p> <p><img src="./assets/img/image-20230327170951336.10353eb3.png" alt="image-20230327170951336"></p> <p>以上只是画了布隆过滤器的很小很小的一部分，实际布隆过滤器是非常大的数组（这里的大是指它的<strong>长度大</strong>，并不是指它所占的<strong>内存空间大</strong>）。</p> <p><strong>那么一个数据是怎么存进布隆过滤器的呢？</strong></p> <p>当一个数据进行存入布隆过滤器的时候，会经过如干个哈希函数进行哈希（若是对哈希函数还不懂的请参考这一片[]），得到对应的哈希值作为数组的下标，然后将初始化的位数组对应的下标的值修改为1，结果图如下：</p> <p><img src="./assets/img/image-20230327171027685.d02fc3cd.png" alt="image-20230327171027685"></p> <p>当再次进行存入第二个值的时候，修改后的结果的原理图如下：</p> <p><img src="./assets/img/image-20230327171124956.d6a27d64.png" alt="image-20230327171124956"></p> <p>所以每次存入一个数据，就会哈希函数的计算，计算的结果就会作为下标，在布隆过滤器中有多少个哈希函数就会计算出多少个下标，布隆过滤器插入的流程如下：</p> <ol><li><p>将要添加的元素给m个哈希函数</p></li> <li><p>得到对应于位数组上的m个位置</p></li> <li><p>将这m个位置设为1</p></li></ol> <p><strong>那么为什么会有误判率呢？</strong></p> <p>假设在我们多次存入值后，在布隆过滤器中存在x、y、z这三个值，布隆过滤器的存储结构图如下所示：</p> <p><img src="./assets/img/image-20230327171307577.2e6b605a.png" alt="image-20230327171307577"></p> <p>当我们要查询的时候，比如查询a这个数，实际中a这个数是不存在布隆过滤器中的，经过2哥哈希函数计算后得到a的哈希值分别为2和13，结构原理图如下：</p> <p><img src="./assets/img/image-20230327171405603.b60d16ae.png" alt="image-20230327171405603"></p> <p>经过查询后，发现2和13位置所存储的值都为1，但是2和13的下标分别是x和z经过计算后的下标位置的修改，该布隆过滤器中实际不存在a，那么布隆过滤器就会误判改值可能存在，因为布隆过滤器不存<strong>元素值</strong>，所以存在<strong>误判率</strong>。</p> <p>那么具体布隆过布隆过滤的判断的准确率和一下<strong>两个因素</strong>有关：</p> <ol><li><p><strong>布隆过滤器大小</strong>：越大，误判率就越小，所以说布隆过滤器一般长度都是非常大的。</p></li> <li><p><strong>哈希函数的个数</strong>：哈希函数的个数越多，那么误判率就越小。</p></li></ol> <p><strong>那么为什么不能删除元素呢？</strong></p> <p>原因很简单，因为删除元素后，将对应元素的下标设置为零，可能别的元素的下标也引用改下标，这样别的元素的判断就会收到影响，原理图如下：</p> <p><img src="./assets/img/image-20230327171544681.5726d000.png" alt="image-20230327171544681"></p> <p>当你删除z元素之后，将对应的下标10和13设置为0，这样导致x和y元素的下标受到影响，导致数据的判断不准确.</p> <p>布隆过滤器的缺点就是要维持容器中的数据，实时的要更新布隆过滤器中的数据为最新。</p> <h3 id="缓存击穿"><a href="#缓存击穿" class="header-anchor">#</a> <strong>缓存击穿</strong></h3> <p><strong>缓存击穿</strong>是指一个<code>key</code>非常热点，在不停的扛着大并发，<strong>大并发</strong>集中对这一个点进行访问，当这个key在失效的瞬间，持续的<strong>大并发</strong>就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大。</p> <p>缓存击穿这里强调的是<strong>并发</strong>，造成缓存击穿的原因有以下两个：</p> <ol><li><p>该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）</p></li> <li><p>添加到了缓存，reids有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）</p></li></ol> <p>对于缓存击穿的解决方案就是加锁，具体实现的原理图如下：</p> <p><img src="./assets/img/image-20230327172615794.83da19c5.png" alt="image-20230327172615794"></p> <p>当用户出现<strong>大并发</strong>访问的时候，在查询缓存的时候和查询数据库的过程加锁，只能第一个进来的请求进行执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接集中缓存，防止了<strong>缓存击穿</strong>。</p> <p>业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中<code>load</code>数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用<strong>分布式锁</strong>，<strong>单机</strong>的话用普通的锁（<code>synchronized</code>、<code>Lock</code>）就够了。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//分布式的锁实现具体实现的代码如下：</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getProduceNum</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取分布式锁</span>
    <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取库存数</span>
        <span class="token keyword">int</span> num<span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token comment">// 上锁           </span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//减少库存，并存入缓存中</span>
            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;剩余库存为num：&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>num<span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;库存已经为0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">//解锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token string">&quot;OK&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="缓存雪崩"><a href="#缓存雪崩" class="header-anchor">#</a> <strong>缓存雪崩</strong></h3> <p>缓存雪崩 是指在某一个时间段，缓存集中过期失效。此刻无数的请求直接绕开缓存，直接请求数据库。</p> <p>造成缓存雪崩的原因，有以下两种：</p> <p>\1.  reids宕机</p> <p>\2.  大部分数据失效</p> <p>比如天猫双11，马上就要到双11零点，很快就会迎来一波抢购，这波商品在23点集中的放入了缓存，假设缓存一个小时，那么到了凌晨24点的时候，这批商品的缓存就都过期了。</p> <p>而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰，对数据库造成压力，甚至压垮数据库。</p> <p>缓存雪崩的原理图如下，</p> <p>当正常的情况下，key没有大量失效的用户访问原理图如下：</p> <p><img src="./assets/img/image-20230327172933759.db63da58.png" alt="image-20230327172933759"></p> <p>当某一时间点，key大量失效，造成的缓存雪崩的原理图如下：</p> <p><img src="./assets/img/image-20230327173004201.5379a622.png" alt="image-20230327173004201"></p> <p>我们可以在事故前中后三个方面来思考解决方案</p> <ul><li>事故前：redis高可用方案，主从+哨兵，集群方案，避免全盘崩溃</li> <li>事故中：较少数据库的压力，本地Ehcache缓存+限流及降级，避免超过数据库承受压力</li> <li>事故后：做redis持久化，一旦Redis重启，可从磁盘中快速恢复数据</li></ul> <h2 id="redis持久化"><a href="#redis持久化" class="header-anchor">#</a> <strong>redis</strong>持久化</h2> <p><img src="./assets/img/image-20230327173453310.b9f245cb.png" alt="image-20230327173453310"></p> <p><code>Redis</code>是一个基于内存的非关系型的数据库，数据保存在内存中，但是内存中的数据也容易发生丢失。这里Redis就为我们提供了持久化的机制，分别是<code>RDB(Redis DataBase)</code>和<code>AOF(Append Only File)</code>。</p> <p>Redis在以前的版本中是单线程的，而在6.0后对Redis的io模型做了优化，<code>io Thread</code>为多线程的，但是<code>worker Thread</code>仍然是单线程。</p> <p>在Redis启动的时候就会去加载持久化的文件，如果没有就直接启动，在启动后的某一时刻由继续持久化内存中产生的数据。</p> <p>接下来我们就来详细了解Redis的两种持久化机制<code>RDB(Redis DataBase)</code>和<code>AOF(Append Only File)</code>。</p> <h3 id="rdb持久化机制"><a href="#rdb持久化机制" class="header-anchor">#</a> <strong>RDB</strong>持久化机制</h3> <p>什么是RDB持久化呢？RDB持久化就是将当前进程的数据以生成快照的形式持久化到磁盘中。对于快照的理解，我们可以理解为将当前线程的数据以拍照的形式保存下来。</p> <p>RDB持久化的时候会单独fork一个与当前进程一摸一样的子进程来进行持久化，因此RDB持久化有如下特点：</p> <p>\1.  开机恢复数据快。</p> <p>\2.  写入持久化文件快。</p> <p>RDB的持久化也是Redis默认的持久化机制，它会把内存中的数据以快照的形式写入默认文件名为<code>dump.rdb</code>中保存。</p> <p>在安装后的Redis中，Redis的配置都在<code>redis.conf</code>文件中，如下图所示，<code>dbfilename</code>就是配置RDB的持久化文件名.</p> <p><img src="./assets/img/image-20230327173753244.6a642727.png" alt="image-20230327173753244"></p> <p><strong>持久化触发时机</strong></p> <p>在RDB机制中触发内存中的数据进行持久化，有以下三种方式：</p> <p>（1）<strong>save命令：</strong></p> <p>save命令不会fork子进程，通过阻塞当前Redis服务器，直到RDB完成为止，所以该命令在生产中一般不会使用。</p> <p>在redis.conf的配置中<code>dir</code>的配置就是RDB持久化后生成rdb二进制文件所在的位置，默认的位置是<code>./</code>，表示当前位置，哪里启动redis，就会在哪里生成持久化文件，如下图所示：</p> <p><img src="./assets/img/image-20230327174056723.bb6da9e1.png" alt="image-20230327174056723"></p> <p><img src="./assets/img/image-20230327174117990.63986b6a.png" alt="image-20230327174117990"></p> <p>（2）<strong>bgsave命令：</strong></p> <p><code>bgsave</code>命令会在后台fork一个与Redis主线程一摸一样的子线程，由子线程负责内存中的数据持久化。</p> <p>这样fork与主线程一样的子线程消耗了内存，但是不会阻塞主线程处理客户端请求，是以空间换时间的方式快照内存中的数据到到文件中。</p> <p><code>bgsave</code>命令阻塞只会发生在fork子线程的时候，这段时间发生的非常短，可以忽略不计，如下图是 bgsave执行的流程图：</p> <p><img src="./assets/img/image-20230327174240477.204b60e4.png" alt="image-20230327174240477"></p> <p><code>dbfilename</code>是配置生成的文件名，也可以通过命令行使用命令来动态的设置这两个配置，命令如下：</p> <p>config set dir{newDir}</p> <p>config set dbfilename{newFileName}</p> <p>（3）<strong>自动化</strong></p> <p>除了上面在命令行使用save和bgsave命令触发持久化，也可以在<code>redis.conf</code>配置文件中，完成配置，如下图所示：</p> <p><img src="./assets/img/image-20230327174828040.2eb21579.png" alt="image-20230327174828040"></p> <p>在新安装的redis中由默认的以上三个save配置，<code>save 900 1</code>表示900秒内如果至少有1个key值变化，则进行持久化保存数据；</p> <p><code>save 300 10</code>则表示300秒内如果至少有10个key值发生变化，则进行持久化，<code>save 60 10000</code>以此类推。</p> <p>save和bgsave的对比区别：</p> <p>\1.  save是<strong>同步</strong>持久化数据，而bgsave是<strong>异步</strong>持久化数据。</p> <p>\2.  <code>save</code>不会fork子进程，通过<strong>主进程</strong>持久化数据，会<strong>阻塞</strong>处理客户端的请求，而<code>bdsave</code>会<code>fork</code>子进程持久化数据，同时还可以处理客户端请求，高效。</p> <p>\3.  save<strong>不会消耗内存</strong>，而bgsave<strong>会消耗内存</strong>。</p> <p><strong>RDB的优缺点</strong></p> <p><strong>缺点：</strong> RDB持久化后的文件是紧凑的二进制文件，适合于备份、全量复制、大规模数据恢复的场景，对数据完整性和一致性要求不高，<strong>RDB会丢失最后一次快照的数据</strong>。</p> <p><strong>优点：</strong> 开机的恢复数据快，写入持久化文件快。</p> <h3 id="aof持久化机制"><a href="#aof持久化机制" class="header-anchor">#</a> <strong>AOF</strong>持久化机制</h3> <p>AOF持久化机制是以日志的形式记录Redis中的每一次的增删改操作，不会记录查询操作，以文本的形式记录，打开记录的日志文件就可以查看操作记录。</p> <p>AOF是默认不开启的，若是像开启AOF，在如下图的配置修改即可：</p> <p><img src="./assets/img/image-20230327175149078.1a62ef51.png" alt="image-20230327175149078"></p> <p>只需要把<code>appendonly no</code>修改为<code>appendonly yes</code>即可开启，在AOF中通过<code>appendfilename</code>配置生成的文件名，该文件名默认为<code>appendonly.aof</code>，路径也是通过dir配置的，这个于RDB的一样，具体的配置信息如下图所示：</p> <p><img src="./assets/img/image-20230327175313794.a9b5b900.png" alt="image-20230327175313794"></p> <p><strong>AOF****触发机制</strong></p> <p>AOF带来的持久化更加安全可靠，默认提供<strong>三种</strong>触发机制，如下所示：</p> <p>\1.  <code>no</code>：表示等操作系统等数据缓存同步到磁盘中（快、持久化没保证）。</p> <p>\2.  <code>always</code>：同步持久化，每次发生数据变更时，就会立即记录到磁盘中（慢，安全）。</p> <p>\3.  <code>everysec</code>：表示每秒同步一次（默认值，很快，但是会丢失一秒内的数据）。</p> <p>AOF中每秒同步也是异步完成的，<strong>效率是非常高</strong>的，由于该机制对日志文件的写入操作是采用<code>append</code>的形式。</p> <p>因此在写入的过程即使宕机，也不会丢失已经存入日志文件的数据，数据的完整性是非常高的。</p> <p>在新安装的Redis的配置文件中，AOF的配置如下所示：<img src="./assets/img/image-20230327175537529.1bac8ea9.png" alt="image-20230327175537529"></p> <p><strong>AOF重写机制</strong></p> <p>但是，在写入所有的操作到日志文件中时，就会出现日志文件很多重复的操作，甚至是无效的操作，导致日志文件越来越大。</p> <p>所谓的无效的的操作，举个例子，比如某一时刻对一个k++，然后后面的某一时刻k--，这样k的值是保持不变的，那么这两次的操作就是无效的。</p> <p>如果像这样的无效操作很多，记录的文件臃肿，就浪费了资源空间，所以在Redis中出现了<code>rewrite</code>机制。</p> <p>redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</p> <p>重写AOF的日志文件不是读取旧的日志文件瘦身，而是将内存中的数据用命令的方式重写一个AOF文件，重新保存替换原来旧的日志文件，因此内存中的数据才是最新的。</p> <p>重写操作也会<code>fork</code>一个子进程来处理重写操作，重写以内存中的数据作为重写的源，避免了操作的冗余性，保证了数据的最新。</p> <p>在Redis以append的形式将修改的数据写入老的磁盘中 ，同时Redis也会创建一个新的文件用于记录此期间有哪些命令被执行。</p> <p>当AOF的日志文件增长到一定大小的时候Redis就能够bgrewriteaof对日志文件进行重写瘦身。当AOF配置文件大于改配置项时自动开启重写（这里指超过原大小的100%）。</p> <p>该配置可以通过如下的配置项进行配置：</p> <p><img src="./assets/img/image-20230327175933854.afd0f48c.png" alt="image-20230327175933854"></p> <p><strong>AOF</strong>的优缺点</p> <p><strong>优点：</strong> AOF更好保证数据不会被丢失，最多只丢失一秒内的数据，通过fork一个子进程处理持久化操作，保证了主进程不会进程io操作，能高效的处理客户端的请求。</p> <p>另外重写操作保证了数据的有效性，即使日志文件过大也会进行重写。</p> <p>AOF的日志文件的记录可读性非常的高，即使某一时刻有人执行<code>flushall</code>清空了所有数据，只需要拿到aof的日志文件，然后把最后一条的flushall给删除掉，就可以恢复数据。</p> <p><strong>缺点：</strong>  对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。AOF在运行效率上往往会慢于RDB。</p> <h3 id="混合持久化"><a href="#混合持久化" class="header-anchor">#</a> <strong>混合持久化</strong></h3> <p>在redis4.0后混合持久化（RDB+AOF）对重写的优化，4.0版本的混合持久化默认是关闭的，可以通过以下的配置开启混合持久化：</p> <p><img src="./assets/img/image-20230327180623650.a3d3a8f0.png" alt="image-20230327180623650"></p> <p>混合持久化也是通过<code>bgrewriteaof</code>来完成的，不同的是当开启混合持久化时，fork出的子进程先将共享内存的数据以RDB方式写入aof文件中，然后再将重写缓冲区的增量命令以AOF方式写入文件中。</p> <p>写入完成后通知主进程统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。简单的说：新的AOF文件前半段是以RDB格式的全量数据后半段是AOF格式的增量数据。</p> <p><strong>优点：</strong> 混合持久化结合<strong>RDB持久化</strong>和<strong>AOF持久化</strong>的优点，由于绝大部分的格式是RDB格式，加载速度快，增量数据以AOF方式保存，数据更少的丢失。</p> <p><strong>RDB</strong>和AOF优势和劣势</p> <p>rdb适合大规模的数据恢复，由于rdb时异快照的形式持久化数据，恢复的数据快，在一定的时间备份一次，而aof的保证数据更加完整，损失的数据只在秒内。</p> <p>具体哪种更适合生产，在官方的建议中两种持久化机制同时开启，如果两种机制同时开启，优先使用aof持久化机制。</p> <h2 id="redis事务"><a href="#redis事务" class="header-anchor">#</a> <strong>redis事务</strong></h2> <p><strong>Redis事务是一组命令的集合，将多个命令进行打包，然后这些命令会被顺序的添加到队列中，并且按顺序的执行这些命令。</strong></p> <p>Redis事务中没有像Mysql关系型数据库事务隔离级别的概念，不能保证原子性操作，也没有像Mysql那样执行事务失败会进行回滚操作。</p> <p>这个与Redis的特点：快速、高效有着密切的关联，因为一些列回滚操作、像事务隔离级别那这样加锁、解锁，是非常消耗性能的。所以，Redis中执行事务的流程只需要简单的下面三个步骤：</p> <ol><li><p>开始事务（MULTI）</p></li> <li><p>命令入队</p></li> <li><p>执行事务（EXEC）、撤销事务（DISCARD ）</p></li></ol> <p>在Redis中事务的实现主要是通过如下的命令实现的：</p> <table><thead><tr><th><strong>命令</strong></th> <th><strong>功能描述</strong></th></tr></thead> <tbody><tr><td>MULTI</td> <td><strong>事务开始的命令</strong>，执行该命令后，后面执行的对Redis数据类型的<strong>操作命令都会顺序的放进队列中</strong>，等待执行EXEC命令后队列中的命令才会被执行</td></tr> <tr><td>DISCARD</td> <td><strong>放弃执行队列中的命令</strong>，你可以理解为Mysql的回滚操作，<strong>并且将当前的状态从事务状态改为非事务状态</strong>。</td></tr> <tr><td>EXEC</td> <td>执行该命令后<strong>表示顺序执行队列中的命令</strong>，执行完后并将结果显示在客户端，<strong>将当前状态从事务状态改为非事务状态</strong>。若是执行该命令之前有key被执行WATCH命令并且又被其它客户端修改，那么就会放弃执行队列中的所有命令，在客户端显示报错信息，若是没有修改就会执行队列中的所有命令。</td></tr> <tr><td>WATCH key</td> <td>表示指定监视某个key，<strong>该命令只能在<strong><strong>MULTI</strong></strong>命令之前执行</strong>，如果监视的key被其他客户端修改，<strong>EXEC****将会放弃执行队列中的所有命令</strong></td></tr> <tr><td>UNWATCH</td> <td><strong>取消监视之前通过****WATCH</strong> <strong>命令监视的****key</strong>，通过执行EXEC 、DISCARD 两个命令之前监视的key也会被取消监视</td></tr></tbody></table> <p><img src="data:image/png;base64,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" alt="image-20230327182418898"></p> <h2 id="redis的部署模式"><a href="#redis的部署模式" class="header-anchor">#</a> Redis的部署模式</h2> <p>Redis作为缓存的高效中间件，在我们日常的开发中被频繁的使用，今天就来说一说Redis的四种模式，分别是<strong>单机版、主从复制、哨兵、以及集群模式</strong>。</p> <p><strong>主从模式</strong></p> <p><strong>原理</strong></p> <p>主从的原理还算是比较简单的，一主多从，<strong>主数据库（master）可以读也可以写（read/write），从数据库仅读（only read）</strong>。</p> <p>但是，主从模式一般实现<strong>读写分离</strong>，<strong>主数据库仅写（only write）</strong>，减轻主数据库的压力，下面一张图搞懂主从模式的原理</p> <p><img src="./assets/img/image-20230327182837555.f90fe10c.png" alt="image-20230327182837555"></p> <p><strong>哨兵模式</strong></p> <p><strong>原理</strong></p> <p>哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预，这就很蛋疼啊。</p> <p>在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。</p> <p><img src="./assets/img/image-20230327183122950.31528d21.png" alt="image-20230327183122950"></p> <p>所以，总的概括来说，哨兵模式有以下的优点（功能点）：</p> <p>\1.  <strong>监控</strong>：监控master和slave是否正常运行，以及哨兵之间也会相互监控</p> <p>\2.  <strong>自动故障恢复</strong>：当master出现故障的时候，会自动选举一个slave作为master顶上去。（过半选举机制）</p> <p><strong>优点</strong></p> <p>哨兵模式是主从模式的升级版，所以在系统层面提高了系统的可用性和性能、稳定性。当master宕机的时候，能够自动进行故障恢复，需不要人为的干预。</p> <p>哨兵于哨兵之间、哨兵与master之间能够进行及时的监控，心跳检测，及时发现系统的问题，这都是弥补了主从的缺点。</p> <p><strong>缺点</strong></p> <p>哨兵一主多从的模式同样也会遇到写的瓶颈，已经存储瓶颈，若是master宕机了，故障恢复的时间比较长，写的业务就会受到影响。</p> <p>增加了哨兵也增加了系统的复杂度，需要同时维护哨兵模式。</p> <p><strong>Cluster模式</strong></p> <p>最后，Cluster是真正的集群模式了，哨兵解决和主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。</p> <p>集群模式实现了Redis数据的分布式存储，实现数据的分片，每个redis节点存储不同的内容，并且解决了在线的节点收缩（下线）和扩容（上线）问题。</p> <p>集群模式真正意义上实现了系统的高可用和高性能，但是集群同时进一步使系统变得越来越复杂，接下来我们来详细的了解集群的运作原理。</p> <p><strong>数据分区原理</strong></p> <p>集群的原理图还是很好理解的，在Redis集群中采用的使虚拟槽分区算法，会把redis集群分成16384 个槽（0 -16383）。</p> <p>比如：下图所示三个master，会把0 -16383范围的槽可能分成三部分（0-5000）、（5001-11000）、（11001-16383）分别数据三个缓存节点的槽范围。</p> <p><img src="./assets/img/image-20230327183803705.d25ff1d2.png" alt="image-20230327183803705"></p> <p>当客户端请求过来，会首先通过对key进行CRC16 校验并对 16384 取模（CRC16(key)%16383）计算出key所在的槽，然后再到对应的槽上进行取数据或者存数据，这样就实现了数据的访问更新。</p> <p><img src="./assets/img/image-20230327183919228.40c09076.png" alt="image-20230327183919228"></p> <p>之所以进行分槽存储，是将一整堆的数据进行分片，防止单台的redis数据量过大，影响性能的问题。</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2023-6-24 2:06:37 ├F10: AM┤</span></div></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/./2022/09/08/redis/#前言" class="sidebar-link reco-side-前言" data-v-b57cc07c>前言</a></li><li class="level-2" data-v-b57cc07c><a href="/./2022/09/08/redis/#redis基本数据结构" class="sidebar-link reco-side-redis基本数据结构" data-v-b57cc07c>redis基本数据结构</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#redis核心对象" class="sidebar-link reco-side-redis核心对象" data-v-b57cc07c>Redis核心对象</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#string类型" class="sidebar-link reco-side-string类型" data-v-b57cc07c>String类型</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#hash类型" class="sidebar-link reco-side-hash类型" data-v-b57cc07c>Hash类型</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#list类型" class="sidebar-link reco-side-list类型" data-v-b57cc07c>List类型</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#set集合" class="sidebar-link reco-side-set集合" data-v-b57cc07c>Set集合</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#zset集合" class="sidebar-link reco-side-zset集合" data-v-b57cc07c>ZSet集合</a></li><li class="level-2" data-v-b57cc07c><a href="/./2022/09/08/redis/#redis内存分配策略" class="sidebar-link reco-side-redis内存分配策略" data-v-b57cc07c>Redis内存分配策略</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#淘汰策略" class="sidebar-link reco-side-淘汰策略" data-v-b57cc07c>淘汰策略</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#删除过期键策略" class="sidebar-link reco-side-删除过期键策略" data-v-b57cc07c>删除过期键策略</a></li><li class="level-2" data-v-b57cc07c><a href="/./2022/09/08/redis/#redis缓存三大问题" class="sidebar-link reco-side-redis缓存三大问题" data-v-b57cc07c>Redis缓存三大问题</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#缓存穿透" class="sidebar-link reco-side-缓存穿透" data-v-b57cc07c>缓存穿透</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#缓存击穿" class="sidebar-link reco-side-缓存击穿" data-v-b57cc07c>缓存击穿</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#缓存雪崩" class="sidebar-link reco-side-缓存雪崩" data-v-b57cc07c>缓存雪崩</a></li><li class="level-2" data-v-b57cc07c><a href="/./2022/09/08/redis/#redis持久化" class="sidebar-link reco-side-redis持久化" data-v-b57cc07c>redis持久化</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#rdb持久化机制" class="sidebar-link reco-side-rdb持久化机制" data-v-b57cc07c>RDB持久化机制</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#aof持久化机制" class="sidebar-link reco-side-aof持久化机制" data-v-b57cc07c>AOF持久化机制</a></li><li class="level-3" data-v-b57cc07c><a href="/./2022/09/08/redis/#混合持久化" class="sidebar-link reco-side-混合持久化" data-v-b57cc07c>混合持久化</a></li><li class="level-2" data-v-b57cc07c><a href="/./2022/09/08/redis/#redis事务" class="sidebar-link reco-side-redis事务" data-v-b57cc07c>redis事务</a></li><li class="level-2" data-v-b57cc07c><a href="/./2022/09/08/redis/#redis的部署模式" class="sidebar-link reco-side-redis的部署模式" data-v-b57cc07c>Redis的部署模式</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----></div></div>
    <script src="./assets/js/app.4a054e09.js" defer></script><script src="./assets/js/12.ef481976.js" defer></script><script src="./assets/js/1.8757f81f.js" defer></script><script src="./assets/js/8.d3843147.js" defer></script><script src="./assets/js/30.e6c3ce92.js" defer></script>
  </body>
</html>
